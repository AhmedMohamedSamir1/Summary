
- AJAX
   - you can send data or fetch data without page refresh
   - allowing the client to communicate with the server asynchronously without reloading the entire page
   - The Fetch API provides a more modern and cleaner way to perform AJAX requests


------------------------------------------------------------------------------------------------
<< promise >>

- A Promise in JavaScript is an object that represents the eventual completion or failure of an asynchronous operation and its resulting value
- a promise is a way to handle future values that will come in the future.

- A Promise can be in one of three states
	- Pending: The initial state, meaning the operation is not yet completed. [The promise is waiting for something to finish. ]
	- Fulfilled: The state when the asynchronous operation is completed successfully.
	- Rejected: The state when the asynchronous operation has failed


- then() method
	- enabling you to define what should happen after the asynchronous operation represented by the Promise completes successfully or fails.
	- promise.then(onFulfilled, onRejected);
		- onFulfilled (optional): A function that is called when the Promise is fulfilled. It receives the resolved value as its argument.
		- onRejected (optional): A function that is called when the Promise is rejected. It receives the reason for the rejection as its argument.
		- it's commonly used with fullfilled states and rejected states used with catch handler
	- returns a new Promise that allowing you to chain multiple asynchronous operations together in a sequence. This is known as Promise chaining 
	- return number * 2; inside the then() method behaves like Promise.resolve(number * 2). // Returned value passed the next then
	
	- Rejecting a Promise Inside then() 
		- throw new Error(""Number is too small!"") --> reject the promise automatically and the error is passed to the nearest catch() handler.
		- return Promise.reject("Number is too small!"); // "Number is too small!" will passed to the nearest catch() handler 

- catch()
	- the primary purpose of catch() is to handle any errors or rejections that occur during the execution of a Promise chain
  	- but it's often used at the end to handle any errors that might occur in the preceding steps.

---------------------------------------------------------------------------------------------------------------------------
<<  fetch  with then >>

- syntax
	fetch(`URL`, option_object )
	    .then( response => {
		if(response.ok)
		   return response.json() // or handle the response using the format you want
		throw new Error('Network response was not ok');
	    })
	    .then(data => { console.log(data) } )    // Log the data  
  	    .catch(error => console.error('Error:', error)); // Handle any errors (e.g., network issues, parsing errors)

- option_object{
     method: 'POST', // HTTP method (e.g., GET, POST, PUT, DELETE)
     headers:{
    	   'Content-Type': 'application/json',
    	   'Authorization': 'Bearer YOUR_TOKEN_HERE'
     },
	
     body: JSON.stringify(data) // Convert the data object to a JSON string, where data is an object const data = { id: 123, name: 'John Doe' };
   }

- response object - > representing the response to the request.
	Response {
  		body: ReadableStream,  // The body of the response that contain data
  		bodyUsed: false,       // Indicates whether the body has been read
  		headers: Headers,      // The response headers
  		ok: true,              // true if the status is in the range 200-299
  		redirected: false,     // true if the request was redirected
  		status: 200,           // HTTP status code
  		statusText: "OK",      // Status text
  		type: "basic",         // Type of the response (e.g., basic, cors)
  		url: "https://api.example.com/data" // The URL of the request
}

response.json();    // Parses the response body to JSON  	 [return promise that resolves with the result of parsed JSON data] 
response.text()     // parses the response body as plain text.   [return promise that resolves with the response body as a string]
response.formData() // parses  the response body as FormData        
response.blob()     // parses  the response body as a Blob, which represents binary data

-- get example --

         fetch(`/User/GetUsersByPage?pageNumber=${pageNumber}&Date=${null}`, {
             method: 'GET'
         }).then(response=>{
             if(response.ok)
                 return response.json();
             
         }).then(data=>{ console.log(data); })
         .catch(error=>{ console.log(error); })


--- POST exampe ---

    // with MVC Ensure it is fromBody

    fetch(`/tag/addTagViaAPI`, {
        method: 'POST',
        headers:{'Content-Type': 'application/json',},
        body: JSON.stringify({'Name': value}),

    }).then(response=>{
        if(response.ok)
            return response.json();

     }).then(data=>{ console.log(data);  addTagOption(data.name, data.id); })
     .catch(error=>{ console.log(error); })


- fetch return type : 
	- fetch is an asynchronous API that always returns a promise.
	
- to get To Access the Result of Asynchronous method (getAllTags)

  function getAllTags(){    
    return  fetch(`https://localhost:7128/api/Tag`,
        {
            method: 'GET',   
        }
    ).then(Response=>{
        if(Response.ok)
            return Response.json();
    }).then(data=>{
        return data;  
    })
  }



async function fetchTags() {
    const tags = await getAllTags();  // The tags variable will hold the fetched data
    console.log(tags);  // You can now use the `tags` variable
}


ORRRR

let tagsData;
getAllTags().then(data => {
    tagsData = data;  // Store the fetched data in the tagsData variable
    console.log(tagsData);  // Optional: Log the data for debugging
});


--------------------------------------------------------------------------------------------------------------------------

<< fetch with async-await >>

- The async and await keywords in JavaScript provide a more readable and convenient way to work with asynchronous operations,

- async
   - used to define an asynchronous function. 
   - When a function is declared with async, it always returns a Promise, regardless of whether you explicitly return a Promise or not.
   - If you return a value from an async function, it gets wrapped in a Promise. return 5 inside an async function would be equivalent to return Promise.resolve(5)
   - If you throw an error inside an async function, it gets rejected with that error.
   - If an error is thrown inside an async function, it gets wrapped in a rejected Promise.


- await
	- The await keyword is used to pause the execution of an async function until a Promise is resolved (fulfilled) or rejected
	- await makes JavaScript wait for the Promise to settle and returns its resolved value
	- If the Promise is rejected, await throws the rejected value, which can be caught using try...catch.

async function fetchData() {
 
   try {
        
        const response = await fetch('https://api.example.com/data');  // Use await to wait for the fetch promise to resolve

        if (!response.ok) {
            throw new Error('Network response was not ok');
        }

        const data = await response.json(); // Use await to wait for the response to be parsed as JSON
        console.log(data);

    } catch (error) {
        // Handle any errors
        console.error('Error:', error);
    }
}